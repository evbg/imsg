#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on Sat Feb  1 11:42:31 2014

@author: Evgeny Bogodukhov
@email: boevgeny@gmail.com
"""

import re
import logging
import traceback
import json
from ..cyr2lat import cyr2lat



#AHM_780_PART_3_FIELDS = """ ED   NI   AD   RR   EO   FR   EA   AA   DL   PX   RC   EB  FLD  EDL  CRT  MAP  DLA  TOF  TOW  ZFW  ALC""".split()
#print AHM_780_PART_3_FIELDS

AHM_780_PART_3_FIELDS = ['ED', 'NI', 'AD', 'RR', 'EO', 'FR', 'EA', 'AA', 'DL', 'PX', 'RC', 'EB', 'FLD', 'EDL', 'CRT', 'MAP', 'DLA', 'TOF', 'TOW', 'ZFW', 'ALC']


AHM_780_SUBTYPE_LIST = [
    'Departure',                  #DEP
    'Arrival',                    #ATA
    'Delay',                      #DEL
    'Revised_ETA',                #ETA
    'Delayed_Take_Off',           #ATD
    'Arrival_Taxi_Time_Variance', #ARR
    'Return_To_Ramp',             #RTR
    'Return_From_Airborn',        #-
]

AHM_780_FIELD_TO_DETECT_SUBTYPE_MAP = {
    "Departure": ['AD'],
    "Delayed_Take_Off": ['EO'],
    "Return_To_Ramp": ['RR'],
    "Return_From_Airborn": ['FR'],
    "Delay": ['ED', 'NI'],
    "Revised_ETA": ['EA', 'EB', '-AD', '-EO', '-FR'],
    "Arrival_Taxi_Time_Variance": ['AA', 'EB'],
    "Arrival": ['AA', '-EB'],
}

AHM_780_PART_3_MAP = {
    "Departure":
#                5                   6         7    8    8.1  8.2 8.3  8.4  8.5  8.6  8.7  8.8  8.9  8.10 8.11
#                 M                   C         C    O    O    O   O    O    O    O    O    O    O    O    O
    "             AD                  EA        DL   PX   RC   EB  FLD  EDL  CRT  MAP  DLA  TOF  TOW  ZFW  ALC",

    "Delayed_Take_Off":
#                13        14        15        16  16.1      16.2 16.3 16.4           16.5
#                 C         C         O         O    O         O   O     O              O
    "             AD        EO        EA        DL   PX        EB  FLD  EDL            DLA",

    "Return_To_Ramp":
#                17   18                       19             19.1 19.2
#                 C    C                        O              O   O
    "             AD   RR                       DL             EB  FLD",

    "Return_From_Airborn":
#                               20  20.4                     20.5 20.6
#                                C    O                        O   O
    "                            FR   EA                       EB  FLD",

    "Delay":
#      10   11                                 12                 12.3 12.4           12.5
#       C    C                                  O                  O    O              O
    "   ED   NI                                 DL                 FLD  EDL            DLA",

    "Revised_ETA":
#                                    21                       21.3 ???
#                                     C                        O   O
    "                                 EA                       EB  FLD",

    "Arrival_Taxi_Time_Variance":
#                                    22                       23   23.3
#                                     C                        C   O
    "                                 AA                       EB  FLD",

    "Arrival":
#                                    9                            9.4
#                                     M                            O
    "                                 AA                           FLD",
}

def AHM_780_PART_3_MAP_LIST_GEN():
    ret = {}
    for item in AHM_780_PART_3_MAP:
        ret[item] = AHM_780_PART_3_MAP[item].split()
    return ret

#print json.dumps(AHM_780_PART_3_MAP_LIST_GEN(), indent=4)

# AUTOGENERATED BY AHM_780_PART_3_MAP_LIST_GEN() FUNCTION
AHM_780_PART_3_MAP_LIST = {
    "Arrival": [
        "AA",
        "FLD"
    ],
    "Arrival_Taxi_Time_Variance": [
        "AA",
        "EB",
        "FLD"
    ],
    "Departure": [
        "AD",
        "EA",
        "DL",
        "PX",
        "RC",
        "EB",
        "FLD",
        "EDL",
        "CRT",
        "MAP",
        "DLA",
        "TOF",
        "TOW",
        "ZFW",
        "ALC"
    ],
    "Delay": [
        "ED",
        "NI",
        "DL",
        "FLD",
        "EDL",
        "DLA"
    ],
    "Revised_ETA": [
        "EA",
        "EB",
        "FLD"
    ],
    "Delayed_Take_Off": [
        "AD",
        "EO",
        "EA",
        "DL",
        "PX",
        "EB",
        "FLD",
        "EDL",
        "DLA"
    ],
    "Return_To_Ramp": [
        "AD",
        "RR",
        "DL",
        "EB",
        "FLD"
    ],
    "Return_From_Airborn": [
        "FR",
        "EA",
        "EB",
        "FLD"
    ]
}

F = {

    "ED" : """\
#Estimated Departure Time
(?P<ED>
    (?P<ED_ID>
        ED
    )
    (?P<ED_DATE>
        \d{2}
    )
    (?P<ED_TIME>
        \d{4}
    )
    (?=$)
)""",

    "NI" : """\
#Date Time of Next Info
(?P<NI>
    (?P<NI_ID>
        NI
    )
    (?P<NI_DATE>
        \d{2}
    )
    (?P<NI_TIME>
        \d{4}
    )
    (?=$)
)""",

    "AD" : """\
#Off-blocks Time
(?P<AD>

    (?P<AD_ID>
        AD
    )

    (?P<AD_OFF_BLOCK_DATE>
        \d{2}
    )?
    (?P<AD_OFF_BLOCK_TIME>
        \d{4}
    )

    (# < < < ? ? ? НЕОБЯЗАТЕЛЬНЫЙ БЛОК НАЧАЛО

        /

        (?P<AD_AIRBORNE_DATE>
            \d{2}
        )?
        (?P<AD_AIRBORNE_TIME>
            \d{4}
        )

    )?# > > > ? ? ? НЕОБЯЗАТЕЛЬНЫЙ БЛОК КОНЕЦ

)""",

    "RR" : """\
#Return To Ramp Time
(?P<RR>
    (?P<RR_ID>
        RR
    )
    (?P<RR_TIME>
        \d{4}
    )?
    (?=$)
)""",

    "EO" : """\
#Estimated Takeoff Time
(?P<EO>
    (?P<EO_ID>
        EO
    )
    (?P<EO_TIME>
        \d{4}
    )
)""",

    "FR" : """\
#Forced Return Information
(?P<FR>

    (?P<FR_ID>
        FR
    )
    (?P<FR_TOUCH_DOWN_TIME>
        \d{4}
    )?
    (
        /
        (?P<FR_ON_BLOCK_TIME>
            \d{4}
        )
    )?

    (?=$)
)""",

    "EA": """\
#Estimated Time of Touch Down
(?P<EA>
#    (?<=\s)
    (?P<EA_ID>
        EA
    )

    (?P<EA_TOUCH_DOWN_TIME>
        \d{4}
    )
    (
        \s
        (?P<EA_AIRPORT_OF_DESTINATION>
            [A-Z]{3}
        )
    )?
    (?=$)
)
""",

    "AA" : """\
#Touch Down Time
(?P<AA>
    (?P<AA_ID>
        AA
    )
    (

        (?P<AA_TOUCH_DOWN_DATE>
            \d{2}
        )?
        (?P<AA_TOUCH_DOWN_TIME>
            \d{4}
        )
        (
            /
            (?P<AA_ON_BLOCK_DATE>
                \d{2}
            )?
            (?P<AA_ON_BLOCK_TIME>
                \d{4}
            )
        )?
    )?

)""",

    "DL" : """\
#Delay Information
(?P<DL>
    (?P<DL_ID>
        DL
    )
    #коды задержек
    (?P<DL_CODE_0>
        \d{2}
    )
    (
        /
        (?P<DL_CODE_1>
            \d{2}
        )
    )?
    #времена задержек
    (
        (?(DL_CODE_0)
            /
            (?P<DL_TIME_0>
                \d{4}
            )
        )
        (?(DL_CODE_1)
            /
            (?P<DL_TIME_1>
                \d{4}
            )
        )?
    )?
)""",

    "PX" : """\
#Passenger Information
(?P<PX>
    (?P<PX_ID>
        PX
    )
    (?P<PX_DATA>
        [0-9/]+
    )
)""",

    "RC" : """\
#Reclearance Time
(?P<RC>
    (?P<RC_ID>
        RC
    )
    (?P<RC_TIME>
        \d{4}
    )
    \s
    (?P<RC_AIRPORT_OF_RECLEARANCE>
        [A-Z]{3}
    )

)""",

    "EB" : """\
#Estimated On-block Time
(?P<EB>
    (?P<EB_ID>
        EB
    )
    (?P<EB_TIME>
        \d{4}
    )
    (?=$)
)""",

    "FLD" : """\
#Flight Leg Date
(?P<FLD>
    (?P<FLD_ID>
        FLD
    )
    (?P<FLD_DATE>
        \d{2}
    )
    (?=$)
)""",

    "EDL" : """\
#Extra Delay Information
(?P<EDL>
    (?P<EDL_ID>
        EDL
    )
    #коды задержек
    (?P<EDL_CODE_0>
        \d{2}
    )
    (
        /
        (?P<EDL_CODE_1>
            \d{2}
        )
    )?
    #времена задержек
    (
        (?(EDL_CODE_0)
            /
            (?P<EDL_TIME_0>
                \d{4}
            )
        )
        (?(EDL_CODE_1)
            /
            (?P<EDL_TIME_1>
                \d{4}
            )
        )?
    )?
)""",

    "CRT" : """\
#Crew Report Time
(?P<CRT>
    (?P<CRT_ID>
        CRT
    )
    (?P<CRT_DATE_0>
        \d{2}
    )?
    (?P<CRT_TIME_0>
        \d{4}
    )
    (
        /
        (?P<CRT_DATE_1>
            \d{2}
        )?
        (?P<CRT_TIME_1>
            \d{4}
        )
    )?
    (?=$)
)""",

    "MAP" : """\
#Movement After Pushback Time
(?P<MAP>
    (?P<MAP_ID>
        MAP
    )
    (?P<MAP_DATE>
        \d{2}
    )?
    (?P<MAP_TIME>
        \d{4}
    )
    (?=$)
)""",

    "DLA" : """\
#Sub Delay Codes
(?P<DLA>
    (?P<DLA_ID>
        DLA
    )
    (?P<DLA_CODE_0>
        \w{3}
    )?
    /
    (?P<DLA_CODE_1>
        \w{3}
    )?
    /
    (?P<DLA_CODE_2>
        \w{3}
    )?
    /
    (?P<DLA_CODE_3>
        \w{3}
    )?
    (?=$)
)""",

    "TOF" : """\
#Take Off Fuel
(?P<TOF>
    (?P<TOF_ID>
        TOF
    )
    (?P<TOF_FUEL>
        \d{4,6}
    )
    (?=$)
)""",

    "TOW" : """\
#Take Off Weight
(?P<TOW>
    (?P<TOW_ID>
        TOW
    )
    (?P<TOW_WEIGHT>
        \d{5,6}
    )
    (?=$)
)""",

    "ZFW" : """\
#Zero Fuel Weight
(?P<ZFW>
    (?P<ZFW_ID>
        ZFW
    )
    (?P<ZFW_WEIGHT>
        \d{5,6}
    )
    (?=$)
)""",

    "ALC" : """\
#Category of Operations
(?P<ALC>
    (?P<ALC_ID>
        ALC
    )
    (?P<ALC_CATEGORY_CREW>
        \w{1,2}
    )
    (
        /
        (?P<ALC_CATEGORY_AIRCRAFT>
            \w{1,2}
        )
    )?
    (?=$)
)""",
}


def AHM_780_PART_3_PATTERNS_GEN():
    ret = ""
    for item in F:
        item_str = """\
%s?
""" % F[item]
        ret += item_str
    return """\
AHM_780_PART_3_PATTERNS = {
"PATTERN": re.compile(\"\"\"
%s\
\"\"\", re.X|re.S),
"MATCH_METHOD": "finditer"
}
""" % ret


def AHM_780_PART_3_PATTERNS_GEN_DICT():
    ret = ""
    for item in F:
        item_str = """\
%s?
""" % F[item]
        ret += item_str
#    print "*"*40
#    print ret
#    print "*"*40
    return {
    "PATTERN": re.compile(ret, re.X|re.S),
    "MATCH_METHOD": "findall"
    }


#print AHM_780_PART_3_PATTERNS_GEN()
#AUTOGENERATED BY AHM_780_PART_3_PATTERNS_GEN FUNCTION

def AHM_780_PART_3_PATTERNS_GEN_DICT_():
    ret = {}
    for item in F:
        ret[item] = {
            "PATTERN": re.compile(F[item], re.X | re.S),
            "MATCH_METHOD": "finditer",
        }
    return ret

#print AHM_780_PART_3_PATTERNS_GEN_DICT()

AHM_780_PATTERNS = {

    2 : {
    "PATTERN": re.compile("""

    # 1. Standard_Message_Identifier

    (?P<Standard_Message_Identifier>
        MVT|MVA
    )?
        [\n]
    # 2.
    (?P<Flight_Identifier>

        # 2.1
        (?P<Airline_designator>
            [A-Z]{2,3}
        )

        # 2.2
        (?P<Flight_Number>
            \d{3,4}\w?
        )

        #2.3
        /
        (?P<Scheduled_UTC_date_of_departure_out_of_its_originating_station>
            \d{2}
        )
    )
        \.
    #3. Aircraft registration
    (?P<Aircraft_registration>
        \w{2,10}
    )
        \.
    #4. Airport of Movement
    (?P<Airport_of_Movement>
        [A-Z]{3}
    )
""", re.X|re.S),
    "MATCH_METHOD": "search"
    },

    3 : AHM_780_PART_3_PATTERNS_GEN_DICT(),
#    3 : AHM_780_PART_3_PATTERNS,

    4 : {
    "PATTERN": re.compile("""
    # 24. [O] Supplementary Information
    (?P<Supplementary_Information>
        SI.*\Z
    )
""", re.X|re.S),
    "MATCH_METHOD": "finditer"
    }
}

def method_finditer(p, text):
    logging.debug("method_finditer")
    logging.debug(p)
    logging.debug(text)
    ret = {}
    result = p.finditer(text)
    group_name_by_index = dict( [ (v, k) for k, v in p.groupindex.items() ] )
    logging.debug("group_name_by_index: %s" % group_name_by_index)
    for match in result:
        for index in group_name_by_index:
            group_name = group_name_by_index[index]
            ret[group_name] = match.group(index)
    return ret

def method_findall(p, text):
    logging.debug("method_findall")
    logging.debug(p)
    logging.debug(text)
    ret = {}
    result = p.findall(text)
    group_name_by_index = dict( [ (v, k) for k, v in p.groupindex.items() ] )
    logging.debug("group_name_by_index: %s" % group_name_by_index)
    for match_tuple in result:
        logging.debug(match_tuple)
        for n, match in enumerate(match_tuple, 1):
            group_name = group_name_by_index.get(n, None)
            if group_name is None:
                continue
            if match != u"":
                logging.debug("{N}: {MATCH}".format(N=n,MATCH=match))
                ret[group_name] = match
    return ret

def method_search(p, text):
    ret = {}
    result = p.search(text)
    if result is not None:
        for group_name in p.groupindex:
            ret[group_name] = result.group(group_name)
    return ret

def method_split(p, text, split_pattern=None):
    ret = []
    split = split_pattern.split(text)
    for item in split:
        ret.append(method_finditer(p, item))
    return ret

def method_split_hyphen(p, text):
    pattern_hyphen = re.compile("-")
    return method_split(p, text, pattern_hyphen)

methods = {
    "finditer": method_finditer,
    "findall": method_findall,
    "search": method_search,
    "split_hyphen": method_split_hyphen
}

class IATA_msg_parser():

    def __init__(self, raw=None):
        self.raw = raw
        self.msg = None
        self.msg_decoded = None
        self.decode_errors = None

    def extract_msg_from_raw(self, raw=None):
        logging.debug("RAW:\n{RAW}".format(RAW=raw))

        if raw is None:
            raw = self.raw
        if raw is None:
            return None
        ret = None
        raw_lat = cyr2lat(raw)
        logging.debug("RAW_LAT:\n{RAW_LAT}".format(RAW_LAT=raw_lat))
        pattern_msg = re.compile("""

(?P<Message>
    (
        (?P<COR>
            COR
        )
        [\r\n]
    )?
    (?P<DATA>
        (
            (?P<SMI>
                MVT
            )
            [\r\n]
        )
        .*?
    )
    (?=[\r\n]{2}|(\s\Z))
)

""", re.X|re.S)

        ret = method_search(pattern_msg, raw_lat)
        return ret

    def get_parts_from_msg(self, msg):
        ret = {}
        pattern_msg = re.compile("""
(?P<PART2>
    MVT
    [\n]
    .+?
)
    [\n]

(?P<PART3>
    .+?
    (
        (?=\nSI)
        |
        (?=\Z)
    )
)
(?P<PART4>
    SI.+\Z
)?
""", re.X|re.S)

        match = pattern_msg.search(msg)
        if match is not None:
            ret = {
                2: match.group(pattern_msg.groupindex["PART2"]),
                3: match.group(pattern_msg.groupindex["PART3"]),
                4: match.group(pattern_msg.groupindex["PART4"]),
            }
        #
        return ret

    def decode_part(self, part_num, part_raw):
        logging.debug(part_num)
        logging.debug(part_raw)
        pattern_item = AHM_780_PATTERNS[part_num]
        pattern = pattern_item["PATTERN"]
        match_method = pattern_item["MATCH_METHOD"]
        method_func = methods.get(match_method, None)
        if method_func is not None:
            ret = method_func(pattern, part_raw)
        logging.debug(ret)
        return ret

    def decode_parts(self, parts):
        ret = {}
        for part in parts:
            part_raw = parts[part]
            if part_raw is not None:
                part_decoded = self.decode_part(part, part_raw)
                ret[part] = part_decoded
            else:
                ret[part] = {}
        return ret

    def decode(self, raw=None):
        if raw is None:
            raw = self.raw
        else:
            self.raw = raw
        if raw is None:
            return None

        msg_decoded = self.extract_msg_from_raw(raw)
        msg_parts = self.get_parts_from_msg(msg_decoded["DATA"])
        parts_decoded = self.decode_parts(msg_parts)
        smi = msg_decoded.get("SMI", None)

        ret = {
            "MSG": {
                "STANDARD": "IATA",
                "CATEGORY": "AHM",
                "TYPE": smi,
                "SUBTYPE": self.get_subtype(parts_decoded)
            },
            "PARTS": parts_decoded,
        }

        cor = msg_decoded.get("COR", None)
        if cor is not None:
            ret["TAGS"] = {"COR":1}
        return ret

    def get_subtype(self, parts_decoded):
        part_3 = parts_decoded.get(3, None)
        if part_3 is None:
            return None
        for subtype in AHM_780_SUBTYPE_LIST:
            fields = AHM_780_FIELD_TO_DETECT_SUBTYPE_MAP[subtype]
            fields_len = len(fields)
            fields_detected = 0
            for field in fields:
                detect = part_3.get(field[-2:], None)
                if field[0] != "-":
                    if detect is not None:
                        fields_detected += 1
                else:
                    if detect is None:
                        fields_detected += 1
            if fields_len == fields_detected:
                return subtype
